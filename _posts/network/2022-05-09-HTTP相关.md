---
title: HTTP相关
author: hanxitao
date: 2022-05-09 02:21:00 +0800
categories: [网络]
tags: [网络]
---

## 一、HTTP缓存

### 1 HTTP缓存的分类

&emsp;&emsp;HTTP缓存可以分为两大类，强制缓存和协商缓存。两类缓存规则不同，强制缓存在缓存未过期时不需要再请求服务器；协商缓存需要请求服务器来判断是否可以使用缓存。

&emsp;&emsp;两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，即当执行强制缓存规则时，如果缓存生效直接使用缓存，不再执行协商缓存规则。

### 2 强制缓存

#### 2.1 Expires

&emsp;&emsp;Expires是服务器告诉浏览器的缓存过期时间(值为GMT时间)。下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据；反之，则重新请求服务器读取数据。

&emsp;&emsp;使用Expires做缓存控制存在的问题：Expires过期控制不稳定，因为浏览器端可以随意修改时间，导致缓存使用不精准。

#### 2.2 Cache-Control

&emsp;&emsp;针对浏览器和服务器时间不同步的问题，加入了新的缓存方案：Cache-Control。Cache-Control：max-age=10s，即10秒内直接使用缓存。

&emsp;&emsp;Cache-Control的优先级大于Expires。

#### 2.3 强制缓存的缺点

&emsp;&emsp;缓存时间过期后，如果文件没有改动，再次去获取该文件就有点浪费服务器的资源了。

### 3 协商缓存

#### 3.1 Last-Modified和If-Modified-Since

&emsp;&emsp;Last-Modified：服务器在响应请求时，会告诉浏览器所请求资源最后的修改时间。    
&emsp;&emsp;If-Modified-Since：浏览器再次请求服务器的时候请求头会包含此字段，值为在缓存中获得的最后修改时间。    
&emsp;&emsp;服务端收到请求发现请求头有If-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取数据即可。

由于Last-Modified只能精确到秒，因此存在两个问题：

- 如果一个文件在1秒内经常变动，同时服务器给该文件设置无缓存，那么浏览器每次访问该文件都会请求服务器。此时服务器比较该文件最近的修改时间和发给浏览器的上次修改时间，发现都是在同一时间(因为精确到秒)，因此返回给浏览器继续使用本地缓存的消息(304)，但事实上服务器上的该资源已经改动了好多次。

- 如果服务器上的一个资源被修改了好多次，但其实际内容没有发生改变，则会因为Last-Modified时间匹配不上而重新返回该资源给浏览器。

#### 3.2 ETag和If-None-Match

&emsp;&emsp;ETag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。

&emsp;&emsp;If-None-Match：浏览器再次请求服务器的时候请求头会包含此字段，后面的值为在缓存中获取的标识。服务器接收到此报文后发现If-None-Match，则与被请求资源的唯一标识进行对比：

- 不同，说明资源被改动过。则响应整个资源内容，返回状态码200
- 相同，说明资源没有被改动过。则响应header，返回状态码304，浏览器直接从缓存中获取数据