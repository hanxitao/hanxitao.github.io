---
title: HTTP相关
author: hanxitao
date: 2022-05-09 02:21:00 +0800
categories: [网络]
tags: [网络]
---

## 一、HTTP缓存

### 1 HTTP缓存的分类

&emsp;&emsp;HTTP缓存可以分为两大类，强制缓存和协商缓存。两类缓存规则不同，强制缓存在缓存未过期时不需要再请求服务器；协商缓存需要请求服务器来判断是否可以使用缓存。

&emsp;&emsp;两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，即当执行强制缓存规则时，如果缓存生效直接使用缓存，不再执行协商缓存规则。

### 2 强制缓存

#### 2.1 Expires

&emsp;&emsp;Expires是服务器告诉浏览器的缓存过期时间(值为GMT时间)。下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据；反之，则重新请求服务器读取数据。

&emsp;&emsp;使用Expires做缓存控制存在的问题：Expires过期控制不稳定，因为浏览器端可以随意修改时间，导致缓存使用不精准。

#### 2.2 Cache-Control

&emsp;&emsp;针对浏览器和服务器时间不同步的问题，加入了新的缓存方案：Cache-Control。Cache-Control：max-age=10s，即10秒内直接使用缓存。

&emsp;&emsp;Cache-Control的优先级大于Expires。

#### 2.3 强制缓存的缺点

&emsp;&emsp;缓存时间过期后，如果文件没有改动，再次去获取该文件就有点浪费服务器的资源了。

### 3 协商缓存

#### 3.1 Last-Modified和If-Modified-Since

&emsp;&emsp;Last-Modified：服务器在响应请求时，会告诉浏览器所请求资源最后的修改时间。    
&emsp;&emsp;If-Modified-Since：浏览器再次请求服务器的时候请求头会包含此字段，值为在缓存中获得的最后修改时间。    
&emsp;&emsp;服务端收到请求发现请求头有If-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取数据即可。

由于Last-Modified只能精确到秒，因此存在两个问题：

- 如果一个文件在1秒内经常变动，同时服务器给该文件设置无缓存，那么浏览器每次访问该文件都会请求服务器。此时服务器比较该文件最近的修改时间和发给浏览器的上次修改时间，发现都是在同一时间(因为精确到秒)，因此返回给浏览器继续使用本地缓存的消息(304)，但事实上服务器上的该资源已经改动了好多次。

- 如果服务器上的一个资源被修改了好多次，但其实际内容没有发生改变，则会因为Last-Modified时间匹配不上而重新返回该资源给浏览器。

#### 3.2 ETag和If-None-Match

&emsp;&emsp;ETag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）。

&emsp;&emsp;If-None-Match：浏览器再次请求服务器的时候请求头会包含此字段，后面的值为在缓存中获取的标识。服务器接收到此报文后发现If-None-Match，则与被请求资源的唯一标识进行对比：

- 不同，说明资源被改动过。则响应整个资源内容，返回状态码200
- 相同，说明资源没有被改动过。则响应header，返回状态码304，浏览器直接从缓存中获取数据

## 二、HTTP请求方法

### 1.GET方法

GET会显示请求指定的资源，并返回响应主体。一般对它的期望是安全且靡等的。

- 安全：指该操作用于获取信息，而非修改信息。
- 幂等：对同一个URL的多个请求返回同样的结果。

查询字符串是在GET请求的URL中发送的。在URL后加?连接查询字符串，多条查询字符串通过&来连接。

GET请求的一些其他特性：

- GET请求可被缓存
- GET请求保留在浏览器历史记录中
- GET请求可被收藏为书签
- GET请求有长度限制

### 2.HEAD方法

与GET方法一样，都是向服务器发出指定资源的请求，但是没有响应体。

HEAD方法的使用场景：

- 在不获取资源的情况下，了解资源的一些信息，比如：资源大小、类型等
- 通过查看响应中的状态码，可以确定资源是否存在

### 3.POST方法

POST方法用于向指定资源提交数据，请求服务器进行处理(例如提交表单或上传文件)，数据包含在请求体中。

POST可能会创建新的资源或修改现有资源。每次提交，表单的数据被编码到请求体中。

浏览器发出的POST请求的body的主要格式：

- application/x-www-form-urlencoded 用来传输简单的数据
- multipart/form-data 主要用来传输文件内容
- application/json 告诉服务端消息主体是序列化后的JSON字符串
- text/plain 纯文本格式

POST请求的一些其他特性：

- POST请求不会被缓存
- POST请求不会保留在浏览器历史记录中
- POST请求不能被收藏为书签
- POST请求对数据长度没有要求

### 4.PUT方法

PUT方法用于将数据发送到服务器来创建/更新资源。

PUT与POST的主要区别在于，PUT方法是幂等的，即调用一次与调用多次是等价的；而连续调用多次POST方法可能会有副作用。

PUT方法可能的响应：

- 如果目标资源不存在，并且PUT方法成功创建了一份，那么服务器返回201 Created来通知客户端资源已创建
- 如果目标已经存在，并且依照请求中封装的表现形式成功进行了更新，那么服务器返回200 OK或200 Not Content来表示请求的成功完成

### 5.DELETE方法

DELETE方法用于请求服务器删除指定URL所对应的资源。

如果DELETE方法成功执行，可能会有以下几种响应码：

- 202 Accepted：表示请求的操作可能会成功执行，但是尚未开始执行
- 204 Not Content：表示操作已执行，但是没有进一步的相关信息
- 200 OK：表示操作已执行，并且响应中提供了相关状态的描述信息

### 6.PATCH方法

&emsp;&emsp;PATCH方法用于对资源进行部分修改。

&emsp;&emsp;在HTTP协议中，PUT方法已经用来表示对资源进行整体覆盖，而POST方法则没有对标准的补丁格式提供支持。不同于PUT方法，而与POST方法类似，PATCH方法是非幂等的，这就意味着连续多个相同的请求会产生不同的效果。

&emsp;&emsp;要判断一台服务器是否支持PATCH方法，那么就看它是否将其添加到了响应首部 Allow 或者 Access-Control-Allow-Methods（在跨域访问的场合，CORS）的方法列表中 。

&emsp;&emsp;另外一个支持 PATCH 方法的隐含迹象是 Accept-Patch 首部的出现，这个首部明确了服务器端可以接受的补丁文件的格式。