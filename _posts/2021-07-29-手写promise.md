---
title: 手写Promise
author: hanxitao
date: 2021-07-29 19:22:00 +0800
categories: [javascript]
tags: [源码分析]
---

## 一、Promise的几个关键问题

1. 如何改变promise对象的状态？

   （1）resolve(value)：如果当前是pending就会变为resolved

   （2）reject(reason)：如果当前是pending就会变为rejected

   （3）抛出异常：如果当前是pending就会变为rejected

2. promise.then()返回的新的promise的结果的状态由什么决定？
    
    （1）简单表述：由then()指定的回调函数的返回值决定

    （2）详细表述：

    如果抛出异常，新promise变为rejected，reason为抛出的异常

    如果返回的是非promise对象，新promise变为resolved，value为then方法中回调函数的返回值

    如果返回的是一个新的promise对象，此promise对象的结果就会成为新的promise的结果

3. promise传透

   （1）当使用promise的then链式调用时，可以在最后指定失败的回调

   （2）当前任何操作出了异常，都会传递到最后失败的回调中处理
   > 注意：在多个then链式调用时，当在then方法中不写错误处理的函数时，默认的操作：reason => Promise.reject(reason);

4. 中断promise链

   （1）当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数

   （2）办法：在回调函数中返回一个pending状态的promise对象

```javascript
new Promise((resolve, reject) => {
    reject(1);
}).then(
    value => { console.log('onResolved1()', value); return 2; },
    // reason => Promise.reject(reason)
).then(
    value => { console.log('onResolved2()', value); return 3; },
    // reason => Promise.reject(reason)
).then(
    value => { console.log('onResolved3()', value); },
    // reason => Promise.reject(reason)
).catch(reason => {
    console.log('onRejected1()', reason);
    // throw reason;
    // return Promise.reject(reason);
    return new Promise(() => {}); // 返回一个pending状态的promise，中断promise链
}).then(
    value => { console.log('onResolved4()', reason); },
    reason => { console.log('onRejected2()', reason); }
)
```