---
title: vue响应式原理
author: hanxitao
date: 2021-05-23 00:35:00 +0800
categories: [vue]
tags: [源码分析]
---

### vue响应式源码
代码如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
  <div id="app">
    <div>{{message}}</div>
    <input type="text" v-model="message" />
    <p>{{ number }}</p>
  </div>
</body>
<script>
  class Vue {
    constructor(options) {
      this.$options = options;
      this.$data = options.data;
      this.$el = options.el;

      new Observer(this.$data);

      Object.keys(this.$data).forEach(key => {
        this._proxy(key);
      });

      new Compiler(this.$el, this); 
    }

    _proxy(key) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        set(newValue) {
          this.$data[key] = newValue;
        },
        get() {
          return this.$data[key];
        }
      })
    }
  }
</script>
<script>
const app = new Vue({
  el: '#app',
  data: {
    message: 'hello vue',
    number: 1
  }
})
</script>
</html>
```

### Dep类
Dep类的主要目的是：为每一个数据创建一个dep实例，实例中的subs存放每一个节点中使用该数据的watcher
```javascript
class Dep {
  constructor() {
    this.subs = [];
  }
  addSub(sub) {
    this.subs.push(sub);
  }
  notify() {
    this.subs.forEach(sub => {
      sub.update();
    })
  }
}
```

### Observe类
该类的主要作用是：监听每一个数据的变化，首次获取数据的值会触发get方法会把Watch的实例加入到Dep类的subs数组中；为数据重新赋值时会触发set方法，然后通过Dep中的notify方法调用watch实例的update方法达到更新数据的目的
```javascript
class Observer {
  constructor(data) {
    this.data = data;
    Object.keys(data).forEach(key => {
      this.defineReactive(this.data, key, data[key]);
    })
  }
  defineReactive(data, key, val) {
    const dep = new Dep();
    Object.defineProperty(data, key, {
      enumerable: true,
      configurable: true,
      get() {
        if (Dep.target) {
          dep.addSub(Dep.target);
        }
        return val;
      },
      set(newValue) {
        if (newValue === val) {
          return;
        }
        val = newValue;
        dep.notify();
      }
    })
  }
}
```

### Watcher类
该类的主要作用是：为每一个使用data中数据的节点替换为实际的值，该操作会触发数据的get方法
```javascript
class Watcher {
  constructor(node, name, vm, type) {
    this.node = node;
    this.name = name;
    this.vm = vm;
    this.type = type;
    Dep.target = this;
    this.update();
    Dep.target = null;
  }
  update() {
    if (this.type === 'input') {
      this.node.value = this.vm[this.name]
    } else {
      this.node.innerText = this.vm[this.name];
    }
  }
}
```

### Compiler类

该类的主要作用是找到html中使用双大括号的节点，以取到数据名称及该节点，然后new调用Watcher类并且传入上述值及this。

```javascript
const reg = /\{\{(.+)\}\}/;
class Compiler {
  constructor(el, vm) {
    this.el = document.querySelector(el);
    this.vm = vm;
    
    this.frag = this._creteFragment();
    this.el.appendChild(this.frag);
  }
  _creteFragment() {
    const frag = document.createDocumentFragment();
    let child;
    while (child = this.el.firstChild) {
      this._compile(child);
      frag.appendChild(child);
    }
    return frag;
  }
  _compile(node) {
    if (node.nodeType === 1) {
      if (reg.test(node.innerText)) {
        const name = RegExp.$1.trim();
        new Watcher(node, name, this.vm);
      }
      const attrs = node.attributes;
      if (attrs.hasOwnProperty('v-model')) {
        const name = attrs['v-model'].nodeValue;
        new Watcher(node, name, this.vm, 'input');
        node.addEventListener('input', e => {
          this.vm[name] = e.target.value;
        })
      }
    }
  }
}
```