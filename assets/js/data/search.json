[ { "title": "LeetCode之删除每行中的最大值", "url": "/posts/%E5%88%A0%E9%99%A4%E6%AF%8F%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/", "categories": "LeetCode", "tags": "LeetCode", "date": "2022-07-27 01:11:00 +0800", "snippet": "一、题目：删除每行中的最大值给定一个 m x n 大小的矩阵 grid ，由若干正整数组成。执行下述操作，直到 grid 变为空矩阵： 从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。 将删除元素中的最大值与答案相加。二、示例示例：输入：grid = [[1,2,4],[3,3,1]]输出：8三、代码var deleteGreatestValue = function(grid, rowsMaxSum = 0) { var rowsMaxArr = []; for (var i = 0; i &amp;lt; grid.length; i ++) { va..." }, { "title": "图片懒加载", "url": "/posts/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/", "categories": "javascript, EverydayLearnOfJs", "tags": "javascript, EverydayLearn", "date": "2022-06-12 17:27:00 +0800", "snippet": "一、原理图片懒加载技术主要通过监听图片资源容器是否出现在视口区域内，来决定图片是否被加载。那么实现图片懒加载技术的核心就是如何判断元素处于视口区域之内。二、实现思路： 给目标元素指定一张占位图片，将真实的图片链接存储在自定义属性中，通常是data-src。 监听与用户滚动行为相关的scroll事件。 在scroll事件处理程序中利用element.getBoundingClientRect()方法判断目标元素与视口的交叉状态。 当目标元素与视口的交叉状态大于0时，将真实的图片链接赋给目标元素的src属性或者backgroundImage..." }, { "title": "LeetCode之质数因子", "url": "/posts/%E8%B4%A8%E6%95%B0%E5%9B%A0%E5%AD%90/", "categories": "LeetCode", "tags": "LeetCode", "date": "2022-06-11 20:02:00 +0800", "snippet": "一、题目：质数因子功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5）二、示例示例：输入：180输出：2 2 3 3 5三、代码function getCode(num) { let i = 2, arr = []; while (i &amp;lt;= num &amp;amp;&amp;amp; i * i &amp;lt;= num) { while (num % i === 0) { arr.push(i); num /= i; ..." }, { "title": "fixed定位相对于谁", "url": "/posts/fixed%E5%AE%9A%E4%BD%8D/", "categories": "css, EverydayLearnOfCss", "tags": "EverydayLearn, css", "date": "2022-06-10 02:37:00 +0800", "snippet": "一、相对于浏览器正常情况下，fixed定位是相对于浏览器的。代码如下：&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; body { background: gray; } .wrap { width: 200px; height: 200px; position: fixed; left: 50%; ..." }, { "title": "Vue指令之去除input值中间空格", "url": "/posts/Vue%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%8E%BB%E9%99%A4input%E5%80%BC%E4%B8%AD%E9%97%B4%E7%A9%BA%E6%A0%BC/", "categories": "Vue, EverydayLearnOfVue", "tags": "EverydayLearn, Vue", "date": "2022-06-06 01:43:00 +0800", "snippet": "一、代码实现js代码如下：// 获取input元素function getInput(el) { let inputEle; if (el.tagName !== &#39;INPUT&#39;) { inputEle = el.querySelector(&#39;input&#39;); } else { inputEle = el; } return inputEle;}// 去除字符串中的空格function removeSpaceOfString(str) { let arr = str.split(&#39; &..." }, { "title": "LeetCode之字符串最后一个单词的长度", "url": "/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/", "categories": "LeetCode", "tags": "LeetCode", "date": "2022-06-05 19:25:00 +0800", "snippet": "一、题目描述：字符串最后一个单词的长度计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）二、示例示例：输入：hello nowcoder输出：8三、代码function getLastWordLength(str) { let i = str.length - 1; while (i &amp;gt; -1) { if (str[i] === &#39; &#39;) break; i -= 1; } return str.length - 1 - i;}" }, { "title": "Vue自定义指令", "url": "/posts/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/", "categories": "Vue, EverydayLearnOfVue", "tags": "EverydayLearn, Vue", "date": "2022-06-03 21:39:00 +0800", "snippet": "一、自定义指令1.1、简介在Vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。1.2、钩子函数一个指令定义对象可以提供如下几个钩子函数（均为可选）： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定的元素插入父节点时调用（仅保证父节点存在，但不一定已被插入到文档中）。 update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。 com..." }, { "title": "BFC", "url": "/posts/BFC/", "categories": "css, EverydayLearnOfCss", "tags": "EverydayLearn, css", "date": "2022-05-30 01:32:00 +0800", "snippet": "一、BFC的定义BFC(Block formatting context)直译为：块级格式上下文，它是一个独立的渲染区域，只有Block-level Box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。二、BFC的生成 根元素（&amp;lt;html&amp;gt;） 浮动元素（float值不为none） 绝对定位元素（position值为absolute或fixed） 行内元素（display值为inline-block） 表格单元格（display值为table-cell） 表格标题（display值为table-caption..." }, { "title": "三栏布局", "url": "/posts/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/", "categories": "css, EverydayLearnOfCss", "tags": "EverydayLearn, css", "date": "2022-05-29 17:40:00 +0800", "snippet": "一、position实现三栏布局代码如下：&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; * { margin: 0; padding: 0; box-sizing: border-box; } .wrap { height: 200px; position: relative; border: 1px solid black; } .box { height: 100%..." }, { "title": "单多行文本溢出省略号", "url": "/posts/%E5%8D%95%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E5%8F%B7/", "categories": "css, EverydayLearnOfCss", "tags": "EverydayLearn, css", "date": "2022-05-29 01:46:00 +0800", "snippet": "一、单行文本溢出省略号.cut { white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}二、多行文本溢出省略号1、webkit内核的浏览器的解决方法通过添加一个-webkit-line-clamp的属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本行数，为了实现多行文本溢出省略号需搭配其他webkit属性： display:-webkit-box;将元素作为弹性伸缩盒子模型来显示 -webkit-box-orient:vertical;设置伸缩盒子元素内的排列方..." }, { "title": "flex布局最后一行左对齐", "url": "/posts/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%B7%A6%E5%AF%B9%E9%BD%90/", "categories": "css, EverydayLearnOfCss", "tags": "EverydayLearn, css", "date": "2022-05-26 20:44:00 +0800", "snippet": "一、justify-content对齐问题描述在CSS flex布局中，justify-content属性可以控制列表的水平对齐方式，例如：space-between值可以实现两端对齐。但是，如果最后一行的列表个数不满，则就会出现最后一行没有完全垂直对齐的问题。如下代码：&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; justify-content: s..." }, { "title": "事件循环", "url": "/posts/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/", "categories": "javascript", "tags": "js相关", "date": "2022-05-18 01:14:00 +0800", "snippet": "一、JS执行机制JS是一门单线程语言，事件循环是JS实现异步的一种方法，也是JS的执行机制。 同步和异步任务分别进入不同的执行场所，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数进入主线程执行。 上述过程不断重复，也就是常说的事件循环。JS引擎存在monitoring process进程，会持续不断地检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。二、async/a..." }, { "title": "前端路由模式", "url": "/posts/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/", "categories": "javascript", "tags": "js相关", "date": "2022-05-14 18:54:00 +0800", "snippet": "一、多页面应用和单页面应用1. 多页面应用1.1 概念多页面应用指的是每一次页面跳转的时候，服务器都会返回一个新的HTML文档，这种类型的应用叫做多页面应用。1.2 多页面应用的优缺点优点： 首屏时间快：首屏时间叫做首个屏幕内容展现的时间，当我们访问页面的时候服务器返回一个HTML页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度快。 SEO效果好：搜索引擎可以识别HTML内容，多页面应用每个页面所有的内容都放在HTML中，所以SEO效果好。缺点： 切换慢：每次跳转都需要发送一个HTTP请求，如果网络状态不好，在页面间来回跳转时就会有明显的卡顿。2. 单页面应用..." }, { "title": "HTTP相关", "url": "/posts/HTTP%E7%9B%B8%E5%85%B3/", "categories": "网络", "tags": "网络", "date": "2022-05-09 02:21:00 +0800", "snippet": "一、HTTP缓存1 HTTP缓存的分类  HTTP缓存可以分为两大类，强制缓存和协商缓存。两类缓存规则不同，强制缓存在缓存未过期时不需要再请求服务器；协商缓存需要请求服务器来判断是否可以使用缓存。  两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，即当执行强制缓存规则时，如果缓存生效直接使用缓存，不再执行协商缓存规则。2 强制缓存2.1 Expires  Expires是服务器告诉浏览器的缓存过期时间(值为GMT时间)。下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据；反之，则重新请求服务器读取数据。  使用Expires做缓存控制存在的问题：Expire..." }, { "title": "优化checkbox", "url": "/posts/%E4%BC%98%E5%8C%96checkbox/", "categories": "css", "tags": "css", "date": "2022-05-08 17:48:00 +0800", "snippet": "一、效果二、思路使用html原生的标签元素checkbox，在其后加上label标签，然后将checkbox元素隐藏，修改label标签的样式为你想要的样式即可。 label设置for属性为checkbox的id属性值，点击label标签能改变checkbox的checked值。三、代码实现&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; :root { --checked-color: #fff; --ch..." }, { "title": "稀松数组", "url": "/posts/%E7%A8%80%E6%9D%BE%E6%95%B0%E7%BB%84/", "categories": "javascript, EverydayLearnOfJs", "tags": "javascript, EverydayLearn", "date": "2022-05-07 00:17:00 +0800", "snippet": "一、稀松数组const arr1 = new Array(5);//[empty × 5]const arr2 = [1,2,3];arr2[5] = 5;//[1, 2, 3, empty × 2, 5]const arr3 = [1,,,,,];//[1, empty × 4]二、稀松数组的特性 稀松数组在大多数遍历数组的方法中，遇到empty元素的时候，callback函数是不会执行的，如：map、filter、forEachconst arr = [1,2,3];arr[5] = 5;arr.forEach(item =&amp;gt; { console.log(&#39;f..." }, { "title": "大数相加", "url": "/posts/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/", "categories": "javascript, EverydayLearnOfJs", "tags": "javascript, EverydayLearn", "date": "2022-04-28 01:47:00 +0800", "snippet": "一、大数相加产生的问题大数相加会产生精度丢失的问题： 6453234253452432 + 7326362323251323; // 13779596576703756二、解决1. 方法一：转化为数组function bigNumSum(str1, str2) { const arr1 = str1.split(&#39;&#39;).reverse(), arr2 = str2.split(&#39;&#39;).reverse(); const length = Math.max(arr1.length, arr2.length); const r..." }, { "title": "splice在for循环中的问题", "url": "/posts/splice%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "javascript, EverydayLearnOfJs", "tags": "javascript, EverydayLearn", "date": "2022-04-27 11:15:00 +0800", "snippet": "for循环中使用splice的问题由于splice会改变原数组，如果在for循环中使用splice就会导致不能够遍历所有元素。const arr = [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;a&#39;];for (let i = 0; i &amp;lt; arr.length; i ++) { if (arr[i] === &#39;a&#39;) { arr.splice(i, 1); }}console..." }, { "title": "移动端开发相关", "url": "/posts/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/", "categories": "css", "tags": "css", "date": "2022-04-25 00:42:00 +0800", "snippet": "一、相关概念1.屏幕相关1.1 屏幕大小指屏幕对角线长度，单位是英寸（inch）。常见的尺寸有4.7寸、5.5寸、6.1寸等。备注：1英寸(inch) = 2.54厘米(cm)1.2 屏幕分辨率是指屏幕在：横向、纵向上的物理像素点的总数，一般用n * m表示。例如：iPhone6的屏幕分辨率是：750 * 1334注意点： 屏幕分辨率是一个固定值，无法修改。 屏幕分辨率、显示分辨率是两个概念，显示分辨率可修改。 屏幕分辨率 &amp;gt;= 显示分辨率。1.3 屏幕密度又称：屏幕像素密度，是指屏幕上每英寸包含的物理像素点个数。2.像素相关2.1 物理像素又称：设备像素，是一个长度..." }, { "title": "async函数处理异常的方式", "url": "/posts/async-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F/", "categories": "javascript", "tags": "js相关", "date": "2022-04-21 19:46:00 +0800", "snippet": "一、返回Promise对象async函数返回一个Promise对象。async函数内部return语句返回的值会成为then方法回调函数的参数。async function f() { return &#39;hello world&#39;;}f().then(v =&amp;gt; console.log(v)); // hello worldasync函数内部抛出错误，会导致返回的Promise变为rejected状态。抛出的错误对象会被catch方法的回调函数接收到。await命令后面的Promise对象如果变为rejected状态，则reject的参数会被catch方法的..." }, { "title": "css之左右摇摆效果", "url": "/posts/animation-swing/", "categories": "css", "tags": "css", "date": "2022-04-21 15:42:00 +0800", "snippet": "一、效果如下所示：二、代码实现&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; body { display: flex; justify-content: center; align-items: center; height: 100vh; background: linear-gradient(to top, #53..." }, { "title": "css之水球加载效果", "url": "/posts/animation-water-wave/", "categories": "css", "tags": "css", "date": "2022-04-20 11:04:00 +0800", "snippet": "一、效果如下所示：二、代码实现&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style&amp;gt; body { height: 100vh; background: linear-gradient(to bottom, #89f7fe, #66f6ff); } .wave { width: 200px; height: 200..." }, { "title": "手写Vue2.0源码（八）-计算属性原理", "url": "/posts/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2022-02-27 16:36:00 +0800", "snippet": "正文let vm = new Vue({ el: &#39;#app&#39;, data() { return { a: 1, b: 2 } }, template: ` &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;Computed：{c}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Computed：{c}&amp;lt;/p&amp;gt; &amp;lt;/d..." }, { "title": "手写Vue2.0源码（七）-侦听属性原理", "url": "/posts/Vue%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2022-01-19 21:17:00 +0800", "snippet": "正文let vm = new Vue({ el: &#39;#app&#39;, data() { return { a: 1, b: 2 } }, watch: { a(newV, oldV) { console.log(newV, oldV); } }});watch属性的写法有：函数、字符串、对象、数组，watch属性的作用是监听的值发生了变化之后执行传入的回调函数。一、watch属性的初始化// src/state.jsexpor..." }, { "title": "LeetCode之最小时间差", "url": "/posts/%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/", "categories": "LeetCode", "tags": "LeetCode", "date": "2022-01-18 23:30:00 +0800", "snippet": "一、题目描述：最小时间差给定一个 24 小时制（小时:分钟 “HH:MM”）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。二、示例示例1:输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]输出：1示例2:输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]输出：0三、代码var findMinDifference = function(timePoints) { const n = timePoints.length; ..." }, { "title": "LeetCode之供暖气", "url": "/posts/%E4%BE%9B%E6%9A%96%E6%B0%94/", "categories": "LeetCode", "tags": "LeetCode", "date": "2022-01-17 20:23:00 +0800", "snippet": "一、题目描述：供暖气冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。在加热器的加热半径范围内的每个房屋都可以获得供暖。现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。说明：所有供暖器都遵循你的半径标准，加热的半径也一样。二、示例示例1：输入: houses = [1,2,3], heaters = [2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。示例2：输入: houses = [1,2,3,4], heaters = [1,4]..." }, { "title": "手写Vue2.0源码（六）-diff算法原理", "url": "/posts/Vue%E4%B9%8Bdiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-12-28 00:55:00 +0800", "snippet": "正文// Vue实例化let vm = new Vue({ el: &#39;#app&#39;, data() { return { a: 123 } }, template: `&amp;lt;div id=&quot;a&quot;&amp;gt;hello { a }&amp;lt;/div&amp;gt;`});setTimeout(() =&amp;gt; { vm.a = 1;}, 1000);此处，当初始化渲染完成1秒后改变了模板里面a的值，Vue会怎么处理来显示最新的值呢？ 把上次渲染的真..." }, { "title": "手写Vue2.0源码（五）-异步更新原理", "url": "/posts/Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-12-02 00:20:00 +0800", "snippet": "正文let vm = new Vue({ el: &#39;#app&#39;, data() { return { a: 123 }; }, template: `&amp;lt;div id=&quot;a&quot;&amp;gt;hello &amp;lt;/div&amp;gt;`});// 当我们每一次改变数据的时候，渲染watcher都会执行一次，这个是影响性能的setTimeout(() =&amp;gt; { vm.a = 1; vm.a = 2; vm.a = 3;}, 100..." }, { "title": "手写Vue2.0源码（四）-渲染更新原理", "url": "/posts/Vue%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-11-27 15:03:00 +0800", "snippet": "正文 // Vue实例化 let vm = new Vue({ el: &#39;#app&#39;, data() { return { a: 123 }; }, template: `&amp;lt;div id=&quot;a&quot;&amp;gt;hello {a}&amp;lt;/div&amp;gt;` }) // 此处模拟更新 setTimeout(() =&amp;gt; { vm.a = 456..." }, { "title": "手写Vue2.0源码（三）-初始渲染原理", "url": "/posts/Vue%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-11-25 14:29:00 +0800", "snippet": "1.组件挂载入口// src/init.jsimport { mountComponent } from &#39;./lifecycle&#39;;Vue.prototype.$mount = function (el) { const vm = this; const options = vm.$options; el = document.querySelector(el); if (!options.render) { let template = options.template; if (!template &amp;amp..." }, { "title": "函数重载", "url": "/posts/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/", "categories": "javascript", "tags": "手写", "date": "2021-11-23 23:44:00 +0800", "snippet": "函数重载函数名相同，函数的参数列表不同（包括参数个数和参数类型），根据参数的不同执行不同的操作function overload(a) { console.log(&#39;一个参数&#39;);}function overload(a, b) { console.log(&#39;两个参数&#39;);}// 在支持重载的编程语言中，比如javaoverload(1); //一个参数overload(1, 2); //两个参数// 在javascript中overload(1); //两个参数overload(1, 2); // 两个参数js实现函数重载function a..." }, { "title": "手写Vue2.0源码（二）-模板编译原理", "url": "/posts/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-11-20 09:10:00 +0800", "snippet": "正文new Vue({ el: &#39;#app&#39;, data() { return { a: 111 }; }, render(h) { return h(&#39;div&#39;, { id: &#39;a&#39; }, &#39;hello&#39;) }, template: `&amp;lt;div id=&#39;a&#39;&amp;gt;hello&amp;lt;/div&amp;gt;`})按照官网给出的生命周期图，传入的options选项里可以手动配置te..." }, { "title": "手写Vue2.0源码（一）-响应式数据原理", "url": "/posts/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/", "categories": "Vue", "tags": "Vue源码分析", "date": "2021-11-18 09:10:00 +0800", "snippet": "正文Vue的一个核心特点是数据驱动。如果按照以往Jquery的思想，数据变化了想要同步到视图就必须要手动操作DOM更新，但是Vue帮我们做到了数据变动自动更新视图的功能，那在Vue内部就一定有一个机制能监听到数据变化然后触发更新。1.数据初始化new Vue({ el: &#39;#app&#39;, router, store, render: h =&amp;gt; h(App)});这段代码就是Vue实例化的过程，从new操作符可以看出Vue其实就是一个构造函数，传入的参数是一个对象options// src/index.jsimport { initMixin } fro..." }, { "title": "数组扁平化", "url": "/posts/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/", "categories": "javascript", "tags": "手写", "date": "2021-11-15 12:57:00 +0800", "snippet": "1、使用栈的思想实现flat函数function flat(arr) { const result = [], stack = [].concat(arr); while(stack.length !== 0) { const val = stack.pop(); if (Array.isArray(val)) { stack.push(...val); } else { result.unshift(val); } } return resu..." }, { "title": "深度克隆完整版", "url": "/posts/%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%E5%AE%8C%E6%95%B4%E7%89%88/", "categories": "javascript", "tags": "手写", "date": "2021-11-13 14:13:00 +0800", "snippet": " const mapTag = &#39;[object Map]&#39;, setTag = &#39;[object Set]&#39;, arrayTag = &#39;[object Array]&#39;, objectTag = &#39;[object Object]&#39;, argsTag = &#39;[object Arguments]&#39;; const boolTag = &#39;[object Boolean]&#39;, dateTag = &#39;..." }, { "title": "手写Promise", "url": "/posts/%E6%89%8B%E5%86%99promise/", "categories": "javascript", "tags": "手写", "date": "2021-07-29 19:22:00 +0800", "snippet": "一、Promise的几个关键问题 如何改变promise对象的状态？ （1）resolve(value)：如果当前是pending就会变为resolved （2）reject(reason)：如果当前是pending就会变为rejected （3）抛出异常：如果当前是pending就会变为rejected promise.then()返回的新的promise的结果的状态由什么决定？ （1）简单表述：由then()指定的回调函数的返回值决定 （2）详细表述： 如果抛出异常，新promise变为rejected，reason为抛出的..." }, { "title": "数据结构之链表", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/", "categories": "数据结构", "tags": "数据结构", "date": "2021-06-14 10:38:00 +0800", "snippet": "一、链表是什么？链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。二、链表的优点 内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的内存动态管理 链表不必在创建时就确定大小，并且大小可以无限的延伸下去 链表在插入数据时，时间复杂度可以达到O(1)，相对于数组效率高很多三、链表的缺点 访问链表中任何一个位置的元素时，都需要从头开始访问。 无法通过下标直接访问元素，需要从头一个个访问，直到找到对应的元素。四、js实现链表class Node { constructor(element) { // 指向下一个节点 this.next = n..." }, { "title": "单例模式", "url": "/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/", "categories": "javascript", "tags": "设计模式", "date": "2021-05-19 21:51:00 +0800", "snippet": "一、在构造函数上定义属性function Universe(name) { if (typeof Universe.instance === &#39;object&#39;) { return Universe.instance; } this.name = name; this.dream = &quot;big house, fancy car&quot;; this.wanted = &quot;too money&quot;; Universe.instance = this;}效果如下图所示：二、重写构造函数function Universe1(name..." }, { "title": "水平垂直居中", "url": "/posts/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/", "categories": "css", "tags": "css", "date": "2021-05-19 16:58:00 +0800", "snippet": "一、块元素水平垂直居中的方法1. 使用flex&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .wrap { width: 300px; height: 300px; border: 1px solid black; display: flex; align-items: center; justify-content: center; ..." }, { "title": "数组去重", "url": "/posts/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/", "categories": "javascript", "tags": "js相关", "date": "2021-05-16 19:32:00 +0800", "snippet": "使用filter去重const arr = [1,1,3,3,2,2,6,6,5,5,4,4];const newArr = arr.filter((item, index, arr) =&amp;gt; { return arr.indexOf(item) === index;});console.log(newArr); // [1, 3, 2, 6, 5, 4]使用reduce去重const arr = [1,1,3,3,2,2,6,6,5,5,4,4];const newArr1 = arr.reduce((accumulator, current) =&amp;gt; { ..." }, { "title": "first-child与first-of-type的区别", "url": "/posts/first-child%E4%B8%8Efirst-of-type%E7%9A%84%E5%8C%BA%E5%88%AB/", "categories": "css", "tags": "css", "date": "2021-05-15 16:45:00 +0800", "snippet": ":first-child匹配的是父元素的第一个子元素，可以说是结构上的第一个子元素代码如下：&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; div p:first-child { background: lightblue; } div h1:first-child { background: lightcoral; } div span:first-child ..." }, { "title": "浮动", "url": "/posts/%E6%B5%AE%E5%8A%A8/", "categories": "css", "tags": "css", "date": "2021-05-15 14:18:00 +0800", "snippet": "一、浮动的初衷及影响1.1 浮动当初被设计出来的主要目的实现文字环绕图片的排版功能代码如下：&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .wrap { width: 500px; height: 300px; border: 1px solid black; } .float { width: 200px; height: 200px; ..." }, { "title": "函数预编译", "url": "/posts/%E5%87%BD%E6%95%B0%E9%A2%84%E7%BC%96%E8%AF%91/", "categories": "javascript", "tags": "js相关", "date": "2021-05-15 01:00:00 +0800", "snippet": "一、预编译的四个步骤： 创建AO对象 找形参和变量声明，将变量和形参作为AO属性名，值为undefined 将实参和形参统一 在函数体里找函数声明，值赋予函数体function test(a, b) { console.log(a); console.log(b); var b = 234; console.log(b); a = 123; console.log(a); function a() {} var a; b = 234; var b = function () {} console.log(a); console.log(b);}test(1..." }, { "title": "箭头函数", "url": "/posts/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%ADthis%E6%8C%87%E5%90%91/", "categories": "javascript", "tags": "js相关", "date": "2021-05-14 23:23:00 +0800", "snippet": " 箭头函数中的this是：向外层作用域中，一层一层查找this，直到有this的定义 const obj = { aaa() { setTimeout(function () { console.log(this); // window }); setTimeout(() =&amp;gt; { console.log(this); // obj }) }};obj.aaa(); 箭头函数中的this无法被修改const obj1 = { name: &#39;aaa&#39;, fn() { return () =&a..." }, { "title": "三栏布局", "url": "/posts/Three-column-layout/", "categories": "css", "tags": "css", "date": "2021-05-06 16:06:00 +0800", "snippet": "一、流体特性+BFC特性的三栏布局代码如下：&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style&amp;gt; .common { width: 200px; height: 30px; float: left; } .left { background: green; } .right { float: right; background: blue; } .center { ..." }, { "title": "原型", "url": "/posts/prototype-and-__proto__/", "categories": "javascript", "tags": "js相关", "date": "2021-05-04 17:09:00 +0800", "snippet": "一、构造函数1.1 构造函数的实例成员与静态成员实例成员：实例成员就是在构造函数内部，通过this添加的成员。实例成员只能通过实例化对象来访问。静态成员：在构造函数本身上添加的成员，只能通过构造函数来访问function Person(name, age) { // 实例成员 this.name = name; this.age = age;}// 静态成员Person.dream = &#39;money&#39;;let p = new Person(&#39;layman&#39;, 23);console.log(p, p.dream); // Person {name: ..." }, { "title": "Css effect", "url": "/posts/css-effect/", "categories": "css", "tags": "css", "date": "2021-04-28 10:50:00 +0800", "snippet": "1、transform中scale#wrap { position: relative; padding: 8px; background: peru; display: inline-block;}#wrap::after { content: &quot;&quot;; width: 100%; height: 2px; background: red; position: absolute; left: 0; bottom: -2px; transform: scaleX(0); transition: .3s ease-in-out;}#wrap:hov..." }, { "title": "防抖节流", "url": "/posts/debounce-and-throttle/", "categories": "javascript", "tags": "js相关", "date": "2021-04-25 15:30:00 +0800", "snippet": "防抖 所谓防抖，就是指触发事件后n秒后才执行函数，如果在n秒内又触发了事件，则会重新计算函数的执行时间function debounce(func, delay) { let timer; return function () { clearTimeout(timer); timer = setTimeout(() =&amp;gt; { func(...arguments); }, delay); }}节流 所谓节流，就是指连续触发事件在n秒中只执行一次函数function throttle(func, ..." }, { "title": "手写call、apply和bind", "url": "/posts/change-this/", "categories": "javascript", "tags": "手写", "date": "2021-04-24 22:21:00 +0800", "snippet": "call、apply和bind的作用call、apply和bind共同的作用是：改变this指向const obj = { z: 1};function fn(x, y) { return x + y + this.z;}fn.call(obj, 2, 3); // 6fn.apply(obj, [2, 3]); // 6var bound = fn.bind(obj, 2);bound(3); // 6手动实现callFunction.prototype.call_ = function (obj) { obj = obj ? Object(obj) : window; obj..." }, { "title": "正则表达式", "url": "/posts/regular-expression/", "categories": "javascript", "tags": "js相关", "date": "2021-04-23 04:30:00 +0800", "snippet": "什么是正则表达式 正则表达式描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个子串中取出符合某个条件的子串等。正则表达式的创建方式 字面量 实例 var reg = /pattern/flags;var reg = new RegExp(pattern, flags); 字面量和实例的区别 字面量方式不能进行字符串拼接，实例方式可以 var str = &#39;cm&#39;;var reg = /str/; // /str/var reg1 = new RegExp(str + 1..." }, { "title": "Build github pages", "url": "/posts/build-github-pages/", "categories": "tools", "tags": "jekyll", "date": "2021-04-02 16:40:00 +0800", "snippet": "一、安装环境1）ubuntu下安装ruby sudo apt-get install ruby-full build-essential zlib1g-dev安装jekyll和bundler gem install jekyll bundler2）window10下载jekyll并安装切换镜像源 gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/安装bundler和jekyll gem install bundler jekyll安装webrick bundle add we..." } ]
